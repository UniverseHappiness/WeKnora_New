# 部署与运维

<cite>
**本文档引用文件**   
- [docker-compose.yml](file://docker-compose.yml)
- [docker-compose.dev.yml](file://docker-compose.dev.yml)
- [build_images.sh](file://scripts/build_images.sh)
- [migrate.sh](file://scripts/migrate.sh)
- [start_all.sh](file://scripts/start_all.sh)
- [start_dev.sh](file://scripts/start_dev.sh)
- [config.yaml](file://config/config.yaml)
- [Dockerfile.app](file://docker/Dockerfile.app)
- [Dockerfile.app.dev](file://docker/Dockerfile.app.dev)
- [Dockerfile.docreader](file://docker/Dockerfile.docreader)
- [Dockerfile](file://frontend/Dockerfile)
- [00-init-db.sql](file://migrations/paradedb/00-init-db.sql)
</cite>

## 目录
1. [部署方案概述](#部署方案概述)
2. [开发与生产环境配置差异](#开发与生产环境配置差异)
3. [各服务容器化配置说明](#各服务容器化配置说明)
4. [关键脚本用途与执行顺序](#关键脚本用途与执行顺序)
5. [生产环境配置建议](#生产环境配置建议)
6. [监控指标采集](#监控指标采集)
7. [日志管理](#日志管理)
8. [备份恢复策略](#备份恢复策略)
9. [升级流程](#升级流程)
10. [故障处理](#故障处理)

## 部署方案概述

WeKnora_New系统采用Docker和docker-compose进行容器化部署，通过定义多个服务组件实现系统的模块化运行。系统部署方案分为开发环境和生产环境两种模式，分别使用`docker-compose.dev.yml`和`docker-compose.yml`配置文件进行管理。

系统主要由前端、后端应用、文档读取器(docreader)、数据库(PostgreSQL)、对象存储(MinIO)、缓存(Redis)、图数据库(Neo4j)和链路追踪(Jaeger)等服务组成。所有服务通过Docker Compose统一编排，形成一个完整的微服务架构。

部署流程包括镜像构建、环境配置、服务启动和数据库迁移等关键步骤。运维人员可以通过执行预定义的脚本完成系统的部署和维护工作，确保部署过程的一致性和可重复性。

**Section sources**
- [docker-compose.yml](file://docker-compose.yml#L1-L253)
- [docker-compose.dev.yml](file://docker-compose.dev.yml#L1-L253)

## 开发与生产环境配置差异

WeKnora_New系统通过`docker-compose.dev.yml`和`docker-compose.yml`两个配置文件区分开发环境和生产环境的部署配置，主要差异体现在以下几个方面：

### 应用服务配置差异
在开发环境中，应用服务使用`app-dev`作为服务名称，并通过`docker/Dockerfile.app.dev`进行构建。该配置启用了热重载功能，使用`air`工具实现代码修改后的自动重启，便于开发调试。同时，开发环境将本地代码目录挂载到容器中，实现代码的实时同步。

在生产环境中，应用服务使用`app`作为服务名称，通过`docker/Dockerfile.app`构建。该配置不包含热重载功能，而是直接运行编译后的二进制文件，确保生产环境的稳定性和性能。

### 依赖服务配置差异
两个环境的依赖服务（如MinIO、docreader、Jaeger、PostgreSQL、Redis、Neo4j）配置基本一致，都使用相同的镜像和端口映射。这种一致性确保了开发环境和生产环境在依赖服务行为上的一致性，减少了环境差异带来的问题。

### 网络与别名配置
开发环境中的`app-dev`服务在`WeKnora-network`网络中配置了`app`别名，这使得前端服务可以通过相同的主机名`app`访问后端服务，无论是在开发环境还是生产环境中，前端配置无需修改。

### 启动脚本差异
系统提供了`start_dev.sh`和`start_all.sh`两个启动脚本分别用于开发环境和生产环境的启动。`start_dev.sh`使用`docker-compose.dev.yml`配置文件，而`start_all.sh`使用`docker-compose.yml`配置文件，确保了不同环境使用正确的配置。

**Section sources**
- [docker-compose.yml](file://docker-compose.yml#L1-L253)
- [docker-compose.dev.yml](file://docker-compose.dev.yml#L1-L253)
- [start_all.sh](file://scripts/start_all.sh#L1-L729)
- [start_dev.sh](file://scripts/start_dev.sh#L1-L729)

## 各服务容器化配置说明

WeKnora_New系统由多个微服务组成，每个服务都有独立的容器化配置，通过Docker Compose进行统一编排。

### 前端服务(frontend)
前端服务基于Nginx容器运行，使用`wechatopenai/weknora-ui:latest`镜像。服务监听80端口，并通过`FRONTEND_PORT`环境变量进行端口映射。前端服务依赖于后端应用服务的健康状态，只有在后端服务健康时才会启动。

### 后端应用服务(app/app-dev)
后端应用服务是系统的核心，提供API接口和业务逻辑处理。生产环境使用`app`服务名称，开发环境使用`app-dev`服务名称。服务监听8080端口，并通过`APP_PORT`环境变量进行端口映射。应用服务依赖于多个其他服务，包括Redis、PostgreSQL、MinIO、docreader和Neo4j，只有在这些依赖服务健康或启动后，应用服务才会启动。

### 文档读取器服务(docreader)
文档读取器服务负责处理各种文档格式的解析和内容提取，使用`wechatopenai/weknora-docreader:latest`镜像。服务监听50051端口，并通过`DOCREADER_PORT`环境变量进行端口映射。服务通过gRPC健康检查确保服务可用性。

### 数据库服务(postgres)
数据库服务使用`paradedb/paradedb:v0.18.9-pg17`镜像，基于PostgreSQL 17并集成了ParadeDB全文搜索扩展。服务监听5432端口，并通过`DB_PORT`环境变量进行端口映射。数据库初始化脚本`00-init-db.sql`和`01-migrate-to-paradedb.sql`在容器首次启动时自动执行，创建必要的数据库表和扩展。

### 对象存储服务(minio)
MinIO服务提供对象存储功能，使用`minio/minio:latest`镜像。服务监听9000端口（API）和9001端口（控制台），并通过`MINIO_PORT`和`MINIO_CONSOLE_PORT`环境变量进行端口映射。MinIO作为分布式对象存储，用于存储系统中的文件和附件。

### 缓存服务(redis)
Redis服务提供缓存功能，使用`redis:7.0-alpine`镜像。服务监听6379端口，并通过`REDIS_PORT`环境变量进行端口映射。Redis配置了持久化功能，确保数据在容器重启后不会丢失。

### 图数据库服务(neo4j)
Neo4j服务提供图数据库功能，使用`neo4j:latest`镜像。服务监听7474端口（HTTP）和7687端口（Bolt协议）。Neo4j集成了APOC插件，提供了丰富的图数据处理功能。

### 链路追踪服务(jaeger)
Jaeger服务提供分布式链路追踪功能，使用`jaegertracing/all-in-one:latest`镜像。服务暴露多个端口，包括6831/udp、6832/udp、5778、16686、4317、4318、14250、14268和9411，支持多种协议和客户端。

**Section sources**
- [docker-compose.yml](file://docker-compose.yml#L1-L253)
- [docker-compose.dev.yml](file://docker-compose.dev.yml#L1-L253)
- [Dockerfile.app](file://docker/Dockerfile.app#L1-L79)
- [Dockerfile.app.dev](file://docker/Dockerfile.app.dev#L1-L28)
- [Dockerfile.docreader](file://docker/Dockerfile.docreader#L1-L159)
- [Dockerfile](file://frontend/Dockerfile#L1-L36)

## 关键脚本用途与执行顺序

WeKnora_New系统提供了多个关键脚本，用于简化部署和运维操作。

### 镜像构建脚本(build_images.sh)
`build_images.sh`脚本用于从源码构建所有Docker镜像。脚本支持构建应用镜像、文档读取器镜像、前端镜像或所有镜像。脚本会自动检测系统平台（AMD64或ARM64），并为不同平台构建相应的镜像。构建过程中，脚本会设置必要的环境变量，如GOPROXY、GOSUMDB等，并注入版本信息、提交ID、构建时间和Go版本等元数据。

### 数据库迁移脚本(migrate.sh)
`migrate.sh`脚本用于执行数据库迁移操作。脚本依赖于`golang-migrate/migrate`工具，支持`up`、`down`和`create`等命令。`up`命令用于应用所有未执行的迁移脚本，`down`命令用于回滚最后一次迁移，`create`命令用于创建新的迁移脚本。脚本通过环境变量配置数据库连接信息，确保迁移操作的安全性。

### 系统启动脚本(start_all.sh和start_dev.sh)
`start_all.sh`和`start_dev.sh`脚本用于启动整个系统。`start_all.sh`用于生产环境，`start_dev.sh`用于开发环境。脚本提供了丰富的功能，包括启动Ollama服务、启动Docker容器、停止服务、检查环境、列出容器、拉取镜像和重启容器等。脚本会自动检测Docker Compose的可用性，支持`docker compose`和`docker-compose`两种命令格式。

### 执行顺序
正确的执行顺序为：
1. 执行`build_images.sh`构建所有镜像
2. 执行`migrate.sh up`应用数据库迁移
3. 执行`start_all.sh`或`start_dev.sh`启动系统

**Section sources**
- [build_images.sh](file://scripts/build_images.sh#L1-L350)
- [migrate.sh](file://scripts/migrate.sh#L1-L54)
- [start_all.sh](file://scripts/start_all.sh#L1-L729)
- [start_dev.sh](file://scripts/start_dev.sh#L1-L729)

## 生产环境配置建议

为确保WeKnora_New系统在生产环境中的稳定运行，建议遵循以下配置原则：

### 资源分配
根据系统负载合理分配CPU和内存资源。建议为PostgreSQL服务分配至少4GB内存，为应用服务分配至少2GB内存，为docreader服务分配至少4GB内存。对于高并发场景，应适当增加资源分配。

### 持久化存储
确保所有有状态服务的数据目录都挂载到主机的持久化存储上。PostgreSQL的数据目录`/var/lib/postgresql/data`、MinIO的数据目录`/data`、Redis的数据目录`/data`和Neo4j的数据目录`/data`都应挂载到主机的持久化存储上，防止数据丢失。

### 安全配置
所有服务的敏感信息（如数据库密码、API密钥等）都应通过环境变量配置，并避免在配置文件中明文存储。建议使用Docker Secrets或外部配置管理工具管理敏感信息。

### 高可用性
对于关键服务，建议配置高可用性。PostgreSQL可以配置主从复制，Redis可以配置哨兵模式，MinIO可以配置分布式模式。通过负载均衡器将前端请求分发到多个应用实例，提高系统的可用性和性能。

### 网络配置
确保Docker网络配置正确，所有服务都在同一个自定义网络`WeKnora-network`中，以便服务间通信。避免使用默认的bridge网络，以提高网络性能和安全性。

**Section sources**
- [docker-compose.yml](file://docker-compose.yml#L1-L253)
- [config.yaml](file://config/config.yaml#L1-L604)

## 监控指标采集

WeKnora_New系统通过多种方式采集监控指标，确保系统的可观测性。

### 内建健康检查
所有关键服务都配置了健康检查，通过Docker的healthcheck机制定期检查服务状态。应用服务通过HTTP端点`/health`检查，MinIO通过`/minio/health/live`端点检查，docreader通过gRPC健康检查探针检查，PostgreSQL通过`pg_isready`命令检查。

### 分布式链路追踪
系统集成了Jaeger作为分布式链路追踪系统，通过OpenTelemetry协议采集和展示服务间的调用链路。应用服务配置了OTLP导出器，将追踪数据发送到Jaeger的4317端口。通过Jaeger UI可以查看详细的调用链路、耗时和错误信息。

### 应用性能监控
应用服务通过内置的监控功能采集性能指标，包括请求处理时间、数据库查询时间、缓存命中率等。这些指标可以通过Prometheus等监控系统采集，并通过Grafana进行可视化展示。

### 基础设施监控
建议使用外部监控工具（如Prometheus、Zabbix等）监控主机的CPU、内存、磁盘和网络使用情况。通过cAdvisor等工具采集容器的资源使用情况，及时发现资源瓶颈。

**Section sources**
- [docker-compose.yml](file://docker-compose.yml#L1-L253)
- [config.yaml](file://config/config.yaml#L1-L604)

## 日志管理

WeKnora_New系统采用集中式日志管理策略，确保日志的完整性和可追溯性。

### 日志输出
所有服务的日志都输出到标准输出(stdout)和标准错误(stderr)，由Docker守护进程统一收集。应用服务、docreader服务和前端服务都配置了详细的日志记录，包括请求日志、错误日志和调试日志。

### 日志轮转
通过Docker的日志驱动配置日志轮转策略，避免日志文件无限增长。建议配置`json-file`日志驱动，并设置`max-size`和`max-file`参数，如`max-size="10m"`和`max-file="3"`，确保单个日志文件不超过10MB，最多保留3个日志文件。

### 日志采集
建议使用ELK（Elasticsearch、Logstash、Kibana）或EFK（Elasticsearch、Fluentd、Kibana）等日志采集系统，从Docker守护进程收集日志，并进行集中存储和分析。通过Kibana等工具可以方便地查询和分析日志。

### 日志级别
在生产环境中，建议将日志级别设置为INFO或WARN，避免产生过多的调试日志。在排查问题时，可以临时调整为DEBUG级别，获取更详细的日志信息。

**Section sources**
- [docker-compose.yml](file://docker-compose.yml#L1-L253)
- [config.yaml](file://config/config.yaml#L1-L604)

## 备份恢复策略

为确保WeKnora_New系统的数据安全，必须制定完善的备份恢复策略。

### 数据库备份
PostgreSQL数据库是系统的核心数据存储，必须定期备份。建议采用以下备份策略：
- 全量备份：每天凌晨执行一次全量备份，使用`pg_dump`命令将整个数据库导出为SQL文件
- 增量备份：每小时执行一次WAL归档备份，确保数据丢失时间窗口不超过1小时
- 备份存储：将备份文件存储到独立的存储系统，如云存储或网络附加存储(NAS)，避免与生产系统共用存储

### 对象存储备份
MinIO中的对象存储数据也应定期备份。可以使用MinIO的`mc mirror`命令将数据同步到另一个MinIO实例或云存储服务，实现异地备份。

### 配置备份
所有配置文件，包括`docker-compose.yml`、`config.yaml`、`.env`文件等，都应纳入版本控制系统(Git)，并定期备份。建议使用Git仓库存储配置文件的历史版本，便于回滚和审计。

### 恢复演练
定期进行恢复演练，验证备份的有效性。恢复演练应包括数据库恢复、对象存储恢复和配置恢复，确保在真实故障发生时能够快速恢复系统。

**Section sources**
- [docker-compose.yml](file://docker-compose.yml#L1-L253)
- [config.yaml](file://config/config.yaml#L1-L604)
- [00-init-db.sql](file://migrations/paradedb/00-init-db.sql#L1-L205)

## 升级流程

WeKnora_New系统的升级流程应遵循以下步骤，确保升级过程的安全性和可回滚性。

### 准备阶段
1. 备份当前系统的所有数据，包括数据库、对象存储和配置文件
2. 检查新版本的变更日志，了解升级可能带来的影响
3. 在测试环境中验证新版本的功能和性能

### 升级阶段
1. 停止当前运行的容器：`docker-compose down`
2. 构建新版本的镜像：`./scripts/build_images.sh --all`
3. 应用数据库迁移：`./scripts/migrate.sh up`
4. 启动新版本的容器：`./scripts/start_all.sh`

### 验证阶段
1. 检查所有服务的健康状态
2. 验证核心功能是否正常工作
3. 监控系统性能指标，确保没有性能下降

### 回滚计划
如果升级后发现问题，应立即执行回滚计划：
1. 停止新版本的容器
2. 恢复备份的数据库和配置文件
3. 启动旧版本的容器

**Section sources**
- [docker-compose.yml](file://docker-compose.yml#L1-L253)
- [build_images.sh](file://scripts/build_images.sh#L1-L350)
- [migrate.sh](file://scripts/migrate.sh#L1-L54)
- [start_all.sh](file://scripts/start_all.sh#L1-L729)

## 故障处理

当WeKnora_New系统出现故障时，应按照以下步骤进行排查和处理。

### 服务不可用
如果某个服务不可用，首先检查该服务的容器状态：
```bash
docker-compose ps
```
查看服务是否处于运行状态。如果服务未运行，查看日志以确定原因：
```bash
docker-compose logs <service_name>
```

### 数据库连接失败
如果应用服务无法连接数据库，检查：
1. PostgreSQL容器是否正常运行
2. 数据库连接参数（主机、端口、用户名、密码）是否正确
3. 数据库是否已正确初始化

### 性能问题
如果系统响应缓慢，检查：
1. 各服务的资源使用情况（CPU、内存）
2. 数据库查询性能，优化慢查询
3. 缓存命中率，确保热点数据被有效缓存

### 数据不一致
如果发现数据不一致，检查：
1. 数据库事务是否正确提交
2. 缓存与数据库的一致性
3. 分布式锁的使用是否正确

### 紧急恢复
在紧急情况下，可以执行以下操作：
1. 重启相关服务：`docker-compose restart <service_name>`
2. 清理缓存：`docker-compose exec redis redis-cli flushall`
3. 恢复到上一个稳定版本

**Section sources**
- [docker-compose.yml](file://docker-compose.yml#L1-L253)
- [start_all.sh](file://scripts/start_all.sh#L1-L729)